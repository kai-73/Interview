## Collections Lite

[1. Что такое "коллекция"?](#1-Что-такое-коллекция)

[2. Перечислите основные методы из интерфейса Collection](#2-Перечислите-основные-методы-из-интерфейса-Collection)

[3. Назовите преимущества использования коллекций?](#3-Назовите-преимущества-использования-коллекций)

[4. Какие данные могут хранить коллекции?](#4-Какие-данные-могут-хранить-коллекции)

[5. Какие есть типы коллекций? Как они характеризуются?](#5-Какие-есть-типы-коллекций-Как-они-характеризуются)

[6. Назовите основные реализации List, Set, Map?](#5-Назовите-основные-реализации-List,-Set,-Map)

[7. В чём отличие ArrayList от LinkedList?](#6-В-чём-отличие-ArrayList-от-LinkedList)

[8. В чём отличие HashSet от TreeSet?](#7-В-чём-отличие-HashSet-от-TreeSet)

[9. В чём отличие Set от Map?](#8-В-чём-отличие-Set-от-Map)

[10. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?](#9-Как-задается-порядок-следования-объектов-в-коллекции-Как-отсортировать-коллекцию)

[11. Чем отличается Comparable от Comparator?](#10-Чем-отличается-Comparable-от-Comparator)

[12. Что такое сортировка по принципу Natural Order?](#11-Что-такое-сортировка-по-принципу-Natural-Order)

[13. Что такое equals и hashcode?](#12-Что-такое-equals-и-hashcode)

[14. Какие есть способы перебора всех элементов List?](#13-Какие-есть-способы-перебора-всех-элементов-List)

[15. Как реализован цикл foreach?](#14-Как-реализован-цикл-foreach)

[16. В чем разница между Iterator и ListIterator?](#15-В-чем-разница-между-Iterator-и-ListIterator)

[17. Как происходит удаление элементов из ArrayList?](#16-Как-происходит-удаление-элементов-из-ArrayList)

[18. Как происходит удаление элементов из LinkedList?](#17-Как-происходит-удаление-элементов-из-LinkedList)

[19. Расскажите иерархию интерфейсов Collections framework?](#18-Расскажите-иерархию-интерфейсов-Collections-framework)

[20. Может ли null использоваться в качестве ключа в Map?](#20-Может-ли-null-использоваться-в-качестве-ключа-в-Map)

[21. Может ли Set содержать null?](#21-Может-ли-Set-содержать-null)

[22. Как преобразовать массив строк в ArrayList?](#22-Как-преобразовать-массив-строк-в-ArrayList)

[23. Как отсортировать список в обратном порядке?](#23-Как-отсортировать-список-в-обратном-порядке)

[24. Какие реализации SortedSet вы знаете и в чем их особенность?](#24-Какие-реализации-SortedSet-вы-знаете-и-в-чем-их-особенность)

[25. В каких случаях разумно использовать массив, а не ArrayList?](#25-В-каких-случаях-разумно-использовать-массив-а-не-ArrayList)

[26. Какие коллекции синхронизированы?](#26-Какие-коллекции-синхронизированы)

## 1. Что такое коллекция?

**Коллекции** - это хранилища, поддерживающие различные способы накопения и упорядочивания объектов с целью обеспечения 
эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также
операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#collections-lite)

## 2. Перечислите основные методы из интерфейса Collection

### Основные:

+ Возвращает число элементов в коллекции:
```java
    int size()
```

+ Возвращает `true`, если коллекция пуста, иначе возвращает `false`
```java
    boolean isEmpty()
```

+ Возвращает `true`, если объект item содержится в коллекции, иначе возвращает `false`:
```java
    boolean contains(Object item)
```

+ Возвращает объект `Iterator` для обхода элементов коллекции:
```java
    Iterator<E> iterator()
```

+ Возвращает массив, содержащий все элементы коллекции:
```java
    Object[] toArray()
```

+ Добавляет в коллекцию объект `item`. При удачном добавлении возвращает `true`, при неудачном - `false`:
```java
    boolean add(E item)
```

+ Возвращает `true`, если объект `item` удачно удален из коллекции, иначе возвращается `false`:
```java
    boolean remove(Object item)
```

+ Удаляет все элементы из коллекции:
```java
    void clear()
```

### Остальные:

+ Возвращает `true`, если эта коллекция содержит все элементы указанной коллекции:
```java
    boolean containsAll(Collection<?> c)
```

+ Добавляет в коллекцию все элементы из коллекции `col`. При удачном добавлении возвращает `true`, при неудачном - `false`:
```java
    boolean addAll(Collection<? extends E> col)
```

+ Удаляет все объекты коллекции `col` из текущей коллекции. Если текущая коллекция изменилась, возвращает `true`, иначе
возвращает `false`:
```java
    boolean removeAll(Collection<?> col)
```

+ Удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции `col`. Если текущая коллекция после 
удаления изменилась, возвращает `true`, иначе возвращает `false`:
```java
    boolean retainAll(Collection<?> col)
```

[к оглавлению](#collections-lite)

## 3. Назовите преимущества использования коллекций?

+ отсутствует необходимость следить за размерами коллекции (в отличае от массива);
  
+ позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано 
много методов по добавлению, удалению, сортировке элементов и т.п.;

+ если правильно подобрать коллекцию, то можно увеличить производительность программы;

+ упрощают взаимодействие разных частей программы, т.к. являются универсальным способом хранения и передачи данных.

[к оглавлению](#collections-lite)

## 4. Какие данные могут хранить коллекции?

Коллекции могут хранить любые ссылочные типы данных.

[к оглавлению](#collections-lite)

## 5. Какие есть типы коллекций? Как они характеризуются?

+ **Set** - используется для хранения множеств уникальных объектов. В коллекции этого типа разрешено наличие только одной 
ссылки типа `null`.

+ **Queue** (Deque) - представляет функционал для структур данных в виде очереди (FIFO первый вошел, первый вышел). Эта
  коллекция предназначена для хранения элементов в порядке, нужном для их обработки. Реализует LinkedList.

+ **List** - упорядоченный список. В какой последовательности данные положили, в такой они и хранятся.
Допускаются дубликаты. Доступ к элементам списка осуществляется по индексу.

+ **Map** - карта, ассоциативный массив (Значения хранятся в виде пар ключ=значение. Каждому элементу из множества
ключей соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. 
Map не наследуется от Collection.) 

[Справочник по Java Collections Framework](https://habr.com/ru/post/237043/)

[к оглавлению](#collections-lite)

## 6. Назовите основные реализации List, Set, Map?

+ **List:**

1. ArrayList - простой список объектов
2. LinkedList - представляет связанный список

+ **Set:** 

1. HashSet - набор объектов или хеш-множество, где каждый элемент имеет ключ - уникальный хеш-код.
2. TreeSet - набор отсортированных объектов в виде дерева.
3. LinkedHashSet - расширяет класс HashSet. Класс поддерживает связный список элементов набора в том порядке, в котором 
они вставлялись.

+ **Map:** 

1. HashMap - структура данных в виде словаря, в котором каждый объект имеет уникальный ключ и некоторое значение.
2. TreeMap - структура данных в виде дерева, где каждый элемент имеет уникальный ключи и некоторое значение.
3. LinkedHashMap - отображение с запоминанием порядка, в котором добавлялись элементы.

[к оглавлению](#collections-lite)

## 7. В чём отличие ArrayList от LinkedList?

**ArrayList - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

**LinkedList - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются) 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же `ArrayList` предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#collections-lite)

## 8. В чём отличие HashSet от TreeSet?

Класс `Object` имеет метод `hashCode()`, который используется классом `HashSet` для эффективного размещения объектов, 
заносимых в коллекцию. В классах объектов, заносимых в `HashSet`, этот метод должен быть переопределен `@Override`.

`HashSet` реализован на основе хеш-таблицы, а `TreeSet` - на основе бинарного дерева.

`HashSet` гораздо быстрее чем `TreeSet` (константное время против логарифмического для большинства операций, таких как,
add, remove, contains), но `TreeSet` гарантирует упорядоченность объектов.

[к оглавлению](#collections-lite)

## 9. В чём отличие Set от Map?

`Set` - это интерфейс в иерархии Коллекции, который не может содержать повторяющиеся элементы, тогда как `Map` - это 
интерфейс, который хранит пару ключ и значение. `Set` - это интерфейс, расширяющий интерфейс `Collection`, а `Map` - 
отдельный интерфейс.

[к оглавлению](#Collections-Lite)

## 10. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), 
либо объектом, реализующим интерфейс сравнения `Comparator`.

Можно отсортировать с помощью интерфейса `Comparable` или интерфейса `Comparator`:
 
+ Если объекты коллекции поддерживают интерфейс `Comparable`, то через `Collections.sort(collection)`; 

+ Если нет, то у коллекции вызвать метод `sort()` и передать ему `Comparator` в качестве аргумента `collection.sort(new MyComparator())`.
Либо использовать метод `Collections.sort(collection, new MyComparator())`.

[к оглавлению](#collections-lite)

## 11. Чем отличается Comparable от Comparator?

**Comparable** - используется только для сравнения объектов класса, в котором данный интерфейс реализован. 
Т.е. интерфейс `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей 
реализации (по правилам разработчика). 
`Collections.sort(collection);`

**Comparator** - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. 
Т.е. интерфейс `Comparator` позволяет создавать объекты, которые будут управлять процессом сравнения: 
1. при сортировках в методах `Collections.sort(collection, new MyComparator())`, `Arrays.sort(array, new MyComparator())` 
или `collection.sort(new MyComparator())`
2. при управлении порядком в отсортированных множествах `TreeSet` или отсортированных картах `TreeMap`,
 например `new TreeSet<T> (new MyComparator())`.

**Разница:**

+ `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации 
и, если нет доступа к исходникам, ее невозможно изменить. 

+ `Comparator` позволает определить логику сравнения объектов определенного ссылочного типа вне реализации 
этого типа и эту логику можно в любой момент подменить.

*`Comparable` используется для `natural ordering`, а `Comparator` для `total ordering`.*

[Comparable и Comparator](http://java-online.ru/blog-comparator.xhtml)

[к оглавлению](#collections-lite)

## 12. Что такое сортировка по принципу Natural Order?

Некоторые классы из коробки реализуют естественный порядок `natural order` для сортировки:

+ строки - лексикографический (по алфавиту),
+ числа - числовой, знаковый или без (больше меньше),
+ дата - хронологичский (по датам),
+ файл - лексикографический по имени пути
+ boolean - false < true

В остальных классах сортировку нужно определять в ручном режиме через `Comparable` или `Comparator`.

[к оглавлению](#collections-lite)

## 13. Что такое equals и hashcode?

`Equals` и `hashCode` являются фундаментальными методами объявленные в классе `Object` и содержатся в стандартных 
библиотеках Java.

Метод `equals()` используется для сравнения объектов, а `hashCode()` - для генерации целочисленного кода объекта.
Эти методы широко используются в стандартных библиотеках Java при вставке и извлечению объектов в `HashMap`. Метод 
`equals` также используется для обеспечения хранения только уникальных объектов в `HashSet` и других `Set` реализациях, 
а также в любых других случаях, когда нужно сравнивать объекты.

Реализация по умолчанию метода `equals()` в классе `java.lang.Object` сравнивает ссылки на адреса в памяти, которые 
хранят переменные, и возвращает true только в том случае, если адреса совпадают, другими словами переменные ссылаются 
на один и тот же объект.

Java рекомендует переопределять методы `equals()` и `hashCode()`, если предполагается, что сравнение должно 
осуществляться в соответствии с бизнес-логикой.

Так как `HashMap` в Java полагается на методы equals() и hashCode() для сравнения своих `key` и `values`, то Java 
предлагает следующие правила для переопределения этих методов:

1. Рефлексивность: Объект должен равняться себе самому.
   
2. Симметричность: если `a.equals(b)` возвращает `true`, то `b.equals(a)` должен тоже вернуть `true`.

3. Транзитивность: если `a.equals(b)` возвращает `true` и `b.equals(с)` тоже возвращает `true`, то `c.equals(a)` тоже 
   должен возвращать `true`.
   
4. Согласованность: повторный вызов метода `equals()` должен возвращать одно и тоже значение до тех пор, пока какое-либо 
   значение свойств объекта не будет изменено. То есть, если два объекта равны в Java, то они будут равны пока их 
   свойства остаются неизменными.
   
5. Сравнение `null`: объект должен быть проверен на `null`. Если объект равен `null`, то метод должен вернуть `false`, 
    а не `NullPointerException`. Например `a.equals(null)` должен вернуть `false`.

Соглашение между `equals` и `hashCode` в Java:

1. Если объекты равны по результатам выполнения метода `equals`, тогда их `hashCode` должны быть одинаковыми.

2. Если объекта не равны по результатам выполнения метода `equals`, тогда их `hashCode` могут быть как одинаковыми, так 
   и разными. Однако для повышенной производительности, лучше, чтобы разные объекты возвращали разные коды.

[к оглавлению](#collections-lite)

## 14. Какие есть способы перебора всех элементов List?

+ **циклы** `for`, `while`, `foreach`

```java
for (int i = 0; i < countries.size(); i++) {
    System.out.println(countries.get(i));
}
```

```java
int i = 0;
while (i < countries.size()){
    System.out.println(countries.get(i++));
}
```

```java
for (String country : countries) {
    System.out.println(country);
}    
```

+ **итераторы** `Iterator`, `ListIterator`
```java
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
```

```java
ListIterator<String> listIterator = countries.listIterator();
//в прямом порядке
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
//в обратном порядке
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}    
```

+ **функция `forEach()`** 
    
    + **`Iterable.forEach()`** можно использовать для итерации по элементам списка начиная с Java 8. 
Этот метод определен в интерфейсе Iterable и может принимать лямбда-выражения в качестве параметра.
    ```java
    countries.forEach(System.out::println);
    ```
    
    + **`Stream.forEach()`** Мы также можем преобразовать коллекцию значений в поток и получить доступ 
    к таким операциям, как `forEach()`, `map()`, или `filter()`.
    ```java
    countries.stream().forEach(
        (c) -> System.out.println(c)
    );
    ```
    
[Способы перебора списка](https://www.codeflow.site/ru/article/java-iterate-list)    

[к оглавлению](#collections-lite)

## 15. Как реализован цикл foreach?

`foreach` реализован на основе `Iterator`, т.е. он работает для классов, реализующих интерфейс `Iterable`.

[к оглавлению](#collections-lite)

## 16. В чем разница между Iterator и ListIterator?

`ListIterator` расширяет `Iterator`, отличия следующие:

+ `Iterator` может использоваться для перебора элементов коллекций `Set`, `List` и `Map`. 
`ListIterator` может быть использован только для перебора элементов коллекции `List`

+ `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`. 
`ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`.

+ `ListIterator` позволяет модифицировать список, добавляя/заменяя/удаляя элементы с помощью методов `add()`, `set()`
`remove()`. Iterator не поддерживает данного функционала.

[к оглавлению](#collections-lite)

## 17. Как происходит удаление элементов из ArrayList?

Находится заданный элемент. 
Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а значение `size` уменьшается на 1.

[к оглавлению](#collections-lite)

## 18. Как происходит удаление элементов из LinkedList?

Находится заданный элемент.
Далее заменяются ссылки `previous` и `next` у соседних элементов и таким образом удаляемый элемент выпадает из цепочки.

[к оглавлению](#collections-lite)

## 19. Расскажите иерархию интерфейсов Collections framework?

+ interface **`Collections`** extends **`Iterable`**.
    + interface `Set` (коллекция без дублирования)
        + `HashSet` базирующаяся на `HashMap` В качестве ключа используется добавляемый элемент, 
        а в качестве значения — объект-пустышка (new Object())
        + `LinkedHashSet` в основе лежит `LinkedHashMap`
    + interface `SortedSet` Методы: `first()`, `last()`
        + `TreeSet` (отсортированный список) содержит в себе объект `NavigableMap`.
    + interface `Queue` очередь Методы: `offer()`, `element()`, `peek()`, `poll()`, `remove()`.
    + interface `Deque` двусторонняя очередь `addFirst()`, `addLast()`, `getFist()`, `getLast()`, 
    (`push()`, `pop()` -> использовать как стек)
    + interface `List` упорядоченная коллекция (сохраняет последовательность элементов. можно получить по индексу, можно 
    повторяющиеся, можно по значению первый найденный)
    + `Vector` @deprecated реализация динамического массива объектов. Позволяет хранить любые данные, включая `null` 
    в качестве элемента
        + `Stack` - данная коллекция является расширением коллекции `Vector`. реализация стека `LIFO`.
        + `ArrayList` динамический массив, можно хранить `null`
        + `LinkedList` связный список (implementation `List` & `Deque`)
+ interface **`Map`** (нет итератора, нельзя перебирать в цикле. Можно получить представление в виде коллекции для перебора) 
`get()`, `put()`, `entrySet()`, `keySet()`, `values()`.
    + interface `SortedMap` (по порядку нарастания ключей)
    + interface `NavigableMap`
        + `TreeMap` реализация `Map` основанная на красно-чёрных деревьях (отсортированная по умолчанию `natural odering`, 
        можно задать свой компаратор)
    + `AbstractMap`
    + `HashMap` позволяет использовать `null` как в качестве ключа, так и значения
        + LinkedHashMap  это упорядоченная реализация хэш-таблицы. Аналогично `LinkedList`
    + `WeekHashMap` - реализация хэш-таблицы, которая организована с использованием weak references. 
Другими словами, `Garbage Collector` автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ 
этого элеметна нет жёстких ссылок

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#Collections-Lite)

## 20. Может ли null использоваться в качестве ключа в Map?

`HashMap` оперирует с `null`-ключом без каких-либо проблем. Его `hash` всегда равен `0`. 

В пустой `TreeMap` можно положить единственный `null`-ключ, 
все остальные операции (кроме `size()` и `clear()`, кстати) после этого не работают. 

В непустой `TreeMap` положить `null`-ключ нельзя из-за обязательного вызова `compareTo()`.

[к оглавлению](#Collections-Lite)

## 21. Может ли Set содержать null?

для `HashSet` работает. `TreeSet` — только для первого элемента.

[к оглавлению](#Collections-Lite)

## 22. Как преобразовать массив строк в ArrayList?

```java
Arrays.asList(words)
```

[к оглавлению](#Collections-Lite)

## 23. Как отсортировать список в обратном порядке?

```java
List reversedList = Collections.reverse(list)
```

[к оглавлению](#Collections-Lite)

## 24. Какие реализации SortedSet вы знаете и в чем их особенность?

`TreeSet` - в основе лежит красно-черное дерево, которое умеет само себя балансировать.

`TreeSet` все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

[к оглавлению](#Collections-Lite)

## 25. В каких случаях разумно использовать массив, а не ArrayList?

Рекомендация от Oracle: используйте `ArrayList` вместо массивов. 

Если ответить на этот вопрос нужно по-другому, то можно сказать следующее: 
Массивы могут быть быстрее и кушать меньше памяти. 
Списки теряют в производительности из-за возможности автоматического увеличения размера и сопутствующих проверок.

[к оглавлению](#Collections-Lite)

## 26. Какие коллекции синхронизированы?

Для этого используется пакет `Concurrent`. А также `@Deprecated` `HashTable`, `Vector`.

Получение синхронизированной коллекции из не синхронизированной:
```java
Collections.synchronizedList(list);
Collections.synchronizedSet(set);
Collections.synchronizedMap(map);
```

Получение коллекции только для чтения:
```java
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);
```

[к оглавлению](#Collections-Lite)
