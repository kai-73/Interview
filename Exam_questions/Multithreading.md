## Multithreading

[1. Чем отличается процесс от потока?](#1-Чем-отличается-процесс-от-потока)

[2. Каким образом можно создать поток?](#2-Каким-образом-можно-создать-поток)

[3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-Как-работают-методы-sleep-yield-wait-notify-и-notifyall)

[4. Объясните следующие термины: монитор, мьютекс, критическая секция.](#4-Объясните-следующие-термины-монитор-мьютекс-критическая-секция)

[5. Как работает join()?](#5-Как-работает-join)

[6. Что такое DeadLock? Приведите примеры.](#6-Что-такое-deadlock-Приведите-примеры)

[7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#7-Назовите-различия-между-collectionssynchronizedmapnew-hashmap-и-concurrenthashmap)

[8. Различия в интерфейсах Runnable и Callable.](#8-Различия-в-интерфейсах-runnable-и-callable)

[9. Различя между isInterrupted(), interrupted().](#9-Различия-между-isinterrupted-interrupted)

[10. Что происходит при вызове Thread.interrupt()?](#10-Что-происходит-при-вызове-threadinterrupt)

[11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.](#11-Перечислите-ВСЕ-причины-по-которым-может-выскочить-interruptedexception)

[12. Назовите отличия synchronize{} и ReentrantLock.](#12-Назовите-отличия-synchronize-и-reentrantlock)

[13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.](#13-Приведите-наиболее-существенное-отличие-между-countdownlatch-и-barrier)

[14. Отличие Thread.start() и Thread.run()?](#14-Отличие-threadstart-и-threadrun)

[15. Объясните ключевое слово volatile.](#15-Объясните-ключевое-слово-volatile)

[16. Расскажите про приоритеты потока.](#16-Расскажите-про-приоритеты-потока)

[17. Что такое потоки-демоны?](#17-Что-такое-потоки-демоны)

[18. Назовите все возможные состояния потока.](#18-Назовите-все-возможные-состояния-потока)

[19. Что такое race condition?](#19-Что-такое-race-condition)

[20. Что такое Thread Local переменная?](#20-Что-такое-thread-local-переменная)

[21. Что такое FutureTask?](#21-Что-такое-futuretask)

[22. Что такое Thread Pool?](#22-Что-такое-thread-pool)

[23. Что такое Semaphore?](#23-Что-такое-semaphore)

[24. Чем отличается submit от execute у ExecutorServices?](#24-Чем-отличается-submit-от-execute-у-executorservices)

[25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#25-Чем-отличается-shutdown-от-shutdownnow-у-threadpoolexecutor)

[26. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#26-Как-создать-threadpool-у-executorservice-только-на-1-на-5-на-неограниченное-количество-потоков)

[27. Что такое ReadWriteLock?](#27-Что-такое-readwritelock)

[28. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().](#28-В-чем-отличие-thread-от-futuretask-В-чём-отличие-threadinterrupt-и-futuretaskcancel)

[29. Расскажите про шаблон проектирования Producer Consumer.](#29-Расскажите-про-шаблон-проектирования-producer-consumer)

## 1. Чем отличается процесс от потока?

**Процесс** - экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы 
(например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не
может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, 
необходимо использовать межпроцессорное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами 
и многое другое.

Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой 
доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. 
Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.

---

**Поток (Thread)** - определенный способ выполнения процесса, определяющий последовательность исполнения кода в 
процессе. Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах. 
Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать 
описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах. Так как потоки 
расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные 
потоки и избегать создания новых процессов.

[к оглавлению](#multithreading)

## 2. Каким образом можно создать поток?

+ Создать потомка класса `Thread` и переопределить его метод `run()`;
+ Создать объект класса `Thread`, передав ему в конструкторе экземпляр класса, реализующего интерфейс `Runnable`. Эти 
  интерфейс содержит метод `run()`, который будет выполняться в новом потоке. Поток закончит выполнение, когда звершится
  его метод `run()`.
+ Вызвать метод `submit()` у экземпляра класса реализующего интерфейс `ExecutorService`, передав ему в качестве 
  параметра экземпляр класса реализующего интерфейс `Runnable` или `Callable` (содержит метод `call()`, в котором 
  описывается логика выполнения).

[к оглавлению](#multithreading)

## 3. Как работают методы sleep, yield, wait, notify и notifyAll?

+ `sleep()` - данный метод вызывает "засыпание" текущего потока на заданное время, состояние изменяется с работающий
  (running) на ожидающий (waiting).
+ `yield()` - данный метод служит причиной того, что поток переходит из состояния работающий (running) в состояние 
  работоспособный (runnable), давая возможность другим потокам активизироваться. Но следующий выбранный для запуска 
  поток может и не быть другим.
  
---

Эти методы определены у класса `Object` и предназначены для взаимодействия потоков между собой при межпоточной 
синхронизации.

+ `wait()` - освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не 
  вызовет метод `notify()`/`notifyAll()`;
+ `notify()` - продолжает работу потока, у которого ранее был вызван метод `wait()`;
+ `notifyAll()` - возобновляет работу всех потоков, у которых ранее был вызван метод `wait()`;

Когда вызван метод `wait()`, поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в 
состояние Ожидания (Waiting). Метод `notify()` подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в
состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоково должен стать 
работоспособным. Метод `notifyAll()` заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный
(Runnable). Если ни один поток не находится в ожидании на методе `wait()`, то при вызове `notify()` или `notifyAll()`
ничего не происходит.

Поток может вызвать методы `wait()` или `notify()` для определенного объекта, только если он в данный момент имеет 
блокировку на этот объект. `wait()`, `notify()` и `notifyAll()` должны вызываться только для синхронизованного кода.

[к оглавлению](#multithreading)

## 4. Объясните следующие термины: монитор, мьютекс, критическая секция.

***Критическая секция*** - часть исполняемого кода программы, которая обращается к общему ресурсу, который не должен быть 
одновременно использован более чем одним потоком выполнения. При нахождении в критической секции двух или более потоков 
возникает состояние «гонки». Чтобы избежать состояния гонки, нужно синхронизировать доступ к критическому разделу.

---

***Мьютекс*** - это специальный объект для синхронизации потоков. Он «прикреплен» к каждому объекту в Java. Название 
«мьютекс» происходит от английского «MUTual EXclusion» — «взаимное исключение», и это отлично отражает его 
предназначение. Задача мьютекса — обеспечить такой механизм, чтобы доступ к объекту в определенное время был только у 
одного потока.

![ ](../images/Multithreading/Mutex.webp)

Популярной аналогией мьютекса в реальной жизни можно считать «пример с туалетом». Когда человек заходит в туалет, он 
закрывает изнутри дверь на замок. Туалет выполняет роль объекта, доступ к которому получают несколько потоков. Замок на 
двери туалета — роль мьютекса, а очередь из людей снаружи — роль потоков. Замок на двери — мьютекс туалета: он 
гарантирует, что внутри одновременно может находиться только один человек. Иными словами, только один поток в 
определенное время может работать с общими ресурсами. Попытки других потоков (людей) получить доступ к занятым ресурсам 
будут неудачными.

У мьютекса есть несколько важных особенностей:

1. Возможны только два состояния — «свободен» и «занят». Это упрощает понимание принципа работы: можно провести 
   параллели с булевыми переменными true/false.
2. состояниями нельзя управлять напрямую. В Java нет механизмов, которые позволили бы явно взять объект, получить его 
   мьютекс и присвоить ему нужный статус.

---

***Монитор*** — это дополнительная «надстройка» над мьютексом. Фактически монитор — это «невидимый» для программиста 
кусок кода.

Говоря о мьютексе, можно привести простой пример:

```java
public class Main {
    
   private Object obj = new Object();
   
   public void doSomething() {
       //...какая-то логика, доступная для всех потоков
       synchronized (obj) {
           //логика, которая одновременно доступна только для одного потока
       }
   }
}
```

В блоке кода, который помечен словом `synchronized`, происходит захват мьютекса нашего объекта `obj`. Защитный механизм 
создает именно монитор! Компилятор преобразует слово synchronized в несколько специальных кусков кода.

Вот что будет происходить «под капотом» нашей программы после того, как компилятор преобразует этот код:

```java
public class Main {

   private Object obj = new Object();

   public void doSomething() throws InterruptedException {
       //...какая-то логика, доступная для всех потоков

       //логика, которая одновременно доступна только для одного потока:

       /*до тех пор, пока мьютекс объекта занят -
       любой другой поток (кроме того, который его захватил), спит*/
       while (obj.getMutex().isBusy()) {
           Thread.sleep(1);
       }

       //пометить мьютекс объекта как занятый
       obj.getMutex().isBusy() = true;

       /*выполнить важную работу, при которой доступ к объекту
       должен быть только у одного потока*/
       obj.someImportantMethod();

       //освободить мьютекс объекта
       obj.getMutex().isBusy() = false;
   }
}
```

Здесь с помощью Java-подобного кода отражается то, что происходит в этот момент внутри Java-машины. Однако этот 
псевдокод дает отличное понимание того, что на самом деле происходит с объектом и потоками внутри блока `synchronized` и
как компилятор преобразует это слово в несколько «невидимых» для программиста команд. Монитор в Java выражен с помощью 
слова synchronized. Весь код, который появился вместо слова synchronized в последнем примере, — это и есть монитор.

[к оглавлению](#multithreading)

## 5. Как работает join()?

Метод `join()` вызывается для того, чтобы привязать текущий поток в конец потока для которого вызывается метод. Т.е.
второй поток будет в режиме блокировки пока первый поток не выполнится.

[к оглавлению](#multithreading)

## 6. Что такое DeadLock? Приведите примеры.

**Взаимная блокировка (deadlock)** - явление, при котором все потоки находятся в режиме ожидания. Происходит, когда 
достигаются состояния:

1. взаимного исключения: по крайней мере один ресурс занят в режиме неделимости и, следовательно, только один поток 
   может использовать ресурс в любой данный момент времени.
2. удержания и ожидания: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсы, которые 
   удерживаются другими потоками.
3. отсутствия предочистки: операционная система не переназначивает ресурсы: если они уже заняти, они должны отдаваться 
   удерживающим потокам сразу же.
4. цикличного ожидания: поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт освобождения 
   ресурса заблокированного первым потоком.
   
Простейший способ избежать взаимной блокировки - не допускать цикличного ожидания. Этого можно достичь, получая мониторы
разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.

Например, две девочки Маша и Даша в детском саду делают аппликацию. Для работы каждой нужны ножницы и цветная бумага. 
Предположим Маша взяла ножницы (поток Маша вошла в монитор объекта ножницы), а Даша бумагу (поток Даша вошла в монитор 
объекта бумага). Каждая из них ждет другой предмет и не хочет делиться тем, что взяла. Они не могут продолжить свою 
работу и будут ждать вечно (пока воспитательница не поможет им).

![ ](../images/Multithreading/deadlock.png)

Пример:

```java
public class DeadlockRisk implements Runnable {
    private static class Resource {
    }

    private final Resource scissors = new Resource();
    private final Resource paper = new Resource();

    public void doSun() {
        synchronized (scissors) { // May deadlock here
            System.out.println(Thread.currentThread().getName()
                    + " взяла ножницы для вырезания солнышка");
            synchronized (paper) {
                System.out.println(Thread.currentThread().getName()
                        + " взяла бумагу для вырезания солнышка");
                System.out.println(Thread.currentThread().getName()
                        + " вырезает солнышко");
            }
        }
    }

    public void doCloud() {
        synchronized (paper) { // May deadlock here
            System.out.println(Thread.currentThread().getName()
                    + " взяла бумагу для вырезания облачка");
            synchronized (scissors) {
                System.out.println(Thread.currentThread().getName()
                        + " взяла ножницы для вырезания облачка");
                System.out.println(Thread.currentThread().getName()
                        + " вырезает облачко");
            }
        }
    }

    public void run() {
        doSun();
        doCloud();
    }

    public static void main(String[] args) {
        DeadlockRisk job = new DeadlockRisk();
        Thread masha = new Thread(job, "Маша");
        Thread dasha = new Thread(job, "Даша");
        masha.start();
        dasha.start();
    }
}
```

---

**livelock** - тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в 
зацикленность при попытке получения каких-либо ресурсов. При этом их состояния постоянно изменяются в зависимости друг 
от друга. Фактической ошибки не возникает, но КПД состемы падает до 0. Часто возникает в результате попыток
предотвращения *deadlock*.

> Реальный пример livelock, - когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, 
> отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им 
> направлении.

[к оглавлению](#multithreading)

## 7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.

Оба являются синхронизированными версиями HashMap c различиями в функциональности и внутренней структуре.

`SynchronizedMap` оборачивает обычный Map используя единственный монитор для блокировки, тогда как `ConcurrentHashMap`:
+ позволяет делать неблокирующее чтение (но можно увидеть старые/невалидные данные).
+ на запись делит map на секции, к каждой из которых идет свой объект блокировки (это уменьшает общее время ожидания).

**ConcurrentHashMap** позволяет одновременную модификацию карты из нескольких потоков без необходимости их блокировки.
Операции получения `get` не блокируются, поэтому могут перекрываться с операциями обновления `put` и `remove`.
Считывание происходит очень быстро, в то время как запись выполняется с помощью блокировки. Т.е. несколько потоков
могут одновременно получить/положить пары key-value из ConcurrentHashMap без блокирования/ожидания друг друга.

+ На уровне объекта нет блокировки. Блокировка имеет более мелкую детализацию. `ConcurrentHashMap` состоит из внутренних
  сегментов, которые могут быть заблокированы отдельными потоками, выполняемыми одновременно.
+ Эффект блокировки нижнего уровня заключается в том, что одновременно могут быть и читатели и писатели, что невозможно 
  для синхронизированных коллекций. Это приводит к гораздо большей масштабируемости.
+ `ConcurrentHashMap` не бросает `ConcurrentModificationException`, если один поток пытается изменить его, а другой
  выполняет итерацию по нему. `ConcurrentHashMap` предоставляет `Iterator`, который не требует синхронизации, и даже 
  позволяет изменять карту во время итерации (но не гарантирует, будут ли возвращены элементы, вставленные во время 
  итерации).
+ `ConcurrentHashMap` как и `Hashtable`, в отличие от `HashMap`, не позволяет использовать `null` в качестве ключа или 
  значения.

**Collections.synchronizedMap(new HashMap())** создает синхронизированную версию `HashMap` с блокируемым доступом. Если 
несколько потоков попытаются получить доступ к `SynchronizedMap` одновременно, то им будет разрешено получить/положить 
по однй паре key-value синхроннизированно. Т.е. пока один поток выполняется, все остальные должны ждать, независимо 
хотят ли они получить или положить данные.

+ Каждый метод синхронизируется с использованием блокировки уровня объекта. Таким образом, методы `get` и `put` на 
  `SynchronizedMap` приобретают блокировку.
+ Блокировка всей коллекции снижает производительность, хотя и обеспечивает согласованность (при правильном 
  использовании). Пока один поток захватил монитор, ни один другой поток не может использовать коллекцию. Это не 
  проблема, когда операции вставки или поиска выполняются не интенсивно. Однако когда нужно перебирать карту большого 
  размера, это может занять много времени.
  
[к оглавлению](#multithreading)

## 8. Различия в интерфейсах Runnable и Callable.

Runnable не может вернуть результат или бросить Exception, оба — обертки кода для вызова из других потоков.

+ Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки
  `java.util.concurrent`;
+ Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод `run()`. Классы, реализующие 
  интерфейс Callable - метод `call()`;
+ Метод `run()` является `void` поэтому ничего не возвращает, а метод `call()` возвращает значение типа `V`. Интерфейс 
  `Callable<V>` является параметризованным и тип значения, которое будет возврщаться в методе `call()`, задается этим 
  параметром `V`.
+ Метод `run()` не может выбрасывать проверяемые исключения, в то время как метод `call()` может.

[к оглавлению](#multithreading)

## 9. Различя между isInterrupted(), interrupted().

Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания.
Прерывание потока вызовом метода `Thread.interrupt()` устанавливает этот флаг. Методы `Thread.interrupted()` и 
`isInterrupted()` позволяют проверить, является ли поток прерванным.

+ Статический метод `Thread.interrupted()` проверяет, был ли установлен флаг прерывания у текущего потока.
  При этом флаг прерывания сбрасывается. Фактически, это еще и ограничивает возможность снять флаг прерывания у
  других тредов (нельзя "украсть" прерывание другого треда).

+ Нестатический метод `isInterrupted()` проверяет статус прерывания у потока, для которого этот метод был вызван,
  не изменяя флаг состояния (поэтому можно вызывать несколько раз).

[к оглавлению](#multithreading)

## 10. Что происходит при вызове Thread.interrupt()?

Для корректной остановки потока можно использовать метод класса `Thread` - `interrupt()`. Этот метод выставляет 
некоторый внутренний флаг-статус прерывания. В дальнейшем состояние этого флага можно проверить с помощью метода 
`isInterrupted()` или `Thread.interrupted()` (для текущего потока). Метод `interrupt()` также способен вывести поток из
состояния ожидания или спячки. Т.е. если у потока были вызваны методы `sleep()` или `wait()` – текущее состояние 
прервется и будет выброшено исключение `InterruptedException`. Флаг в этом случае не выставляется.

Схема действия при этом получается следующей:

+ Реализовать поток.
+ В потоке периодически проводить проверку статуса прерывания через вызов `isInterrupted()`.
+ Если состояние флага изменилось или было выброшено исключение во время ожидания/спячки, следовательно поток пытаются 
  остановить извне.
+ Принять решение – продолжить работу (если по каким-то причинам остановиться невозможно) или освободить заблокированные
  потоком ресурсы и закончить выполнение.

Возможная проблема, которая присутствует в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован 
на чтении данных - вызов `interrupt()` из этого состояния его не выведет. Решения тут различаются в зависимости от типа 
источника данных. Если чтение идет из файла – долговременная блокировка крайне маловероятна и тогда можно просто 
дождаться выхода из метода `read()`. Если же чтение каким-то образом связано с сетью – стоит использовать неблокирующий 
ввод-вывод из Java NIO.

[к оглавлению](#multithreading)

## 11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.

Поток ждет в `wait()`, `sleep(…)`, `join()` или заблокирован на длительное время аналогичным вызовом..
и из соседнего потока дернули `interrupt()`.

+ Поток прерван во время ожидания на мониторе
+ Поток прерван во время засыпания
+ Поток прерван во время захвата `ReentrantLock` через `lockInterruptibly`
+ Поток прерван во время ожидания в `CountDownLatch` через `await`
+ Поток прерван во время ожидания в `CyclicBarrier` через `await`
+ Поток прерван во время ожидания в `Condition` через `await`
+ Поток прерван во время захвата попытки в `Semaphore` через `acquireUninterruptibly`
+ Поток прерван во время получения значения в `Future` через `get`
+ Поток прерван во время обмена значенимя в `Exchanger` через `exchange`
+ Поток прерван во время блокирующих операций с `BlockingQueue`
+ Поток прерван во время работы с I/O через `InterruptableChannel`

В общем, почти любой блокирующий метод выбрасывает это исключение.

[к оглавлению](#multithreading)

## 12. Назовите отличия synchronize{} и ReentrantLock.

В Java 5 появился интерфейс `Lock` предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов.
`ReentrantLock` – распространённая реализация `Lock`, которая предоставляет `Lock` с таким же базовым поведением и 
семантикой, как у `synchronized`, но расширенными возможностями, такими как опрос о блокировании (lock polling), 
ожидание блокирования заданной длительности и прерываемое ожидание блокировки. Кроме того, он предлагает гораздо более 
высокую эффективность функционирования в условиях жесткой _состязательности_.

Что понимается под блокировкой с повторным входом (reentrant)? Просто то, что есть подсчет сбора данных, связанный с 
блокировкой, и если поток, который удерживает блокировку, снова ее получает, данные отражают увеличение, и тогда для 
реального разблокирования нужно два раза снять блокировку. Это аналогично семантике synchronized; если поток входит в 
синхронный блок, защищенный монитором, который уже принадлежит потоку, потоку будет разрешено дальнейшее 
функционирование, и блокировка не будет снята, когда поток выйдет из второго (или последующего) блока synchronized, она 
будет снята только когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.

```java
Lock lock = new ReentrantLock();

lock.lock();
try { 
  // update object state
}
finally {
  lock.unlock(); 
}
```

+ Реализация `ReentrantLock` гораздо более масштабируема в условиях состязательности, чем реализация `synchronized`. Это 
  значит, что когда много потоков соперничают за право получения блокировки, общая пропускная способность обычно лучше у 
  `ReentrantLock`, чем у `synchronized`. JVM требуется меньше времени на установление очередности потоков и больше 
  времени на непосредственно выполнение.
+ У `ReentrantLock` (как и у других реализаций `Lock`) блокировка должна обязательно сниматься в `finally` блоке (иначе, 
  если бы защищенный код выбросил исключение, блокировка не была бы снята). Используя синхронизацию, JVM гарантирует, 
  что блокировка автоматически снимаются.

Резюмируя, можно сказать, что когда состязания за блокировку нет либо оно очень мало, то `synchronized` возможно будет 
быстрее. Если присутствует заметное состязание за доступ к ресурсу, то скорее всего `ReentrantLock` даст некое 
преимущество.

[к оглавлению](#multithreading)

## 13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.

`CountDownLatch` (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до 
тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут 
«отпущены», чтобы продолжить свою деятельность. В конструктор `CountDownLatch(int count)` обязательно передается 
количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.

> Примером `CountDownLatch` из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество 
> человек, экскурсия не начнется.

`CyclicBarrier` реализует шаблон синхронизации «Барьер». Циклический барьер является точкой синхронизации, в которой 
указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется 
опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, 
барьер ломается и ожидающие потоки «освобождаются». В конструкторы барьера `CyclicBarrier(int parties)` и 
`CyclicBarrier(int parties, Runnable barrierAction)` обязательно передается количество сторон, которые должны 
«встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они 
будут «отпущены».

> `CyclicBarrier` является альтернативой метода `join()`, который «собирает» потоки только после того, как они 
> выполнились.

`CyclicBarrier` похож на `CountDownLatch`, но главное различие между ними в том, что использовать «замок» можно лишь 
единожды - после того, как его счётчик достигнет нуля, а «барьер» можно использовать неоднократно, даже после того, как 
он «сломается».

[к оглавлению](#multithreading)

## 14. Отличие Thread.start() и Thread.run()?

Несмотря на то, что `start()` вызывает метод `run()` внутри себя, это не то же самое, что просто вызов `run()`. Если 
`run()` вызывается как обычный метод, то он вызывается в том же потоке и никакой новый поток не запускается, как это 
происходит, в случае, когда вы вызываете метод `start()`.

[к оглавлению](#multithreading)

## 15. Объясните ключевое слово volatile.

Модификатор `volatile` вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной.

*Запись* volatile-переменных производится в основную память (медленную), минуя локальную (кэш).

*Чтение* volatile-переменной производится также из основной памяти, т.e. значение переменной не может
сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт
последнее записанное в неё значение.

Поэтому `volatile` дает гарантии happens-before на все присвоения переменных до текущего момента
(так называемый read memory barrier).

Внимание!
+ Если переменная примитивного типа, то этого будет достаточно для обеспечения потокобезопасности.
+ Если переменная является ссылкой на объект, то синхронизировано будет исключительно значение этой ссылки.
  Все же данные, содержащиеся в объекте, синхронизированы не будут.

[к оглавлению](#multithreading)

## 16. Расскажите про приоритеты потока.

***Приоритет (priority)*** потока показывает планировщику, насколько важен этот поток. Хотя порядок обращения процессора
к существующему набору потоков и не детерменирован, если существует несколько приостановленных потоков, одновренно 
ожидающих запуска, планировщик сначала запустит поток с большим приоритетом. Впрочем, это не значит, что потоки с 
младшими приоритетами не выполняются вовсе. Потоки с низкими приоритетами запускаются чуть реже.

В подавляющем большинстве случаев все потоки должны выполняться с приоритетом по умолчанию. Попытки манипулирования с 
приоритетами потоков обычно являются ошибкой.

Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет 
разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. 
Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его 
приоритета.

Чтобы установить приоритет потока, используется метод класса `Thread`: `final void setPriority(int level)`. Значение 
`level` изменяется в пределах от `Thread.MIN_PRIORITY = 1` до `Thread.MAX_PRIORITY = 10`. Приоритет по умолчанию - 
`Thread.NORM_PRIORITY = 5`.

Получить текущее значение приоритета потока можно вызвав метод: `final int getPriority()` у экземпляра класса `Thread`.

[к оглавлению](#multithreading)

## 17. Что такое потоки-демоны?

Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если 
какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в 
обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода 
`setDaemon(boolean value)`, вызванного у потока до его запуска. Метод `boolean isDaemon()` позволяет определить, 
является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока 
приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода `main()`, не 
обращая внимания на то, что поток-демон еще работает.

[к оглавлению](#multithreading)

## 18. Назовите все возможные состояния потока.

Потоки могут находиться в одном из следующих состояний:

+ **Новый (NEW)** - Нить создана, но не запущена.

+ **Работоспособный (RUNNABLE)** Нить запущена и выполняется. Поток переходит в состояние *Работоспособный*, когда 
  вызывается метод `start()`. Когда поток находится в этом состоянии, он считается живым.
  
+ **Живой, но не работоспособный (Alive, but not runnable)** Поток может быть живым, но не работоспособным по нескольким причинам:
  + ***Ожидание (WAITING)*** Нить ожидает уведомления. Поток переходит в состояние *Ожидания*, вызывая метод `wait()`.
    И наоборот вызов `notify()` или `notifyAll()` может перевести поток из состояния *Ожидания* в состояние 
    *Работоспособный*.
  + ***Временное ожидание (TIMED_WAITING)*** нить ожидает уведомление в течении определенного периода. В классе Thread 
    есть статический метод sleep. Он переводит нить в состояние TIMED_WAITING.
  + ***Блокировка (BLOCKED)*** Нить заблокирована. Поток может перейти в это состояние, в ожидании ресурса,
    такого как ввод/вывод или из-за блокировки другого объекта. В случае когда ресурс становится доступен, поток 
    переходит в состояние *Работоспособный*.

+ **Прекращенный (TERMINATED)** Нить завершила работу. Поток считается мёртвым, когда его метод `run()` полностью 
  выполнен. Прекращенный поток не может перейти ни в какое другое состояние, даже если для него вызван метод `start()`.

[к оглавлению](#multithreading)

## 19. Что такое race condition?

**Состояние гонки** (race condition) - ошибка проектирования многопоточной системы или приложения, при которой эта 
работа напрямую зависит от того, в каком порядке выполняются потоки. Состояние гонки возникает, когда поток, который 
должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего 
возникают недетерменированные ошибки.

*Пример race condition:* два потока используют общий ресурс - один объект типа счетчик и одновременно меняют его состояние
Чтобы уйти от состояния гонки, нужно синхронизировать код в критической секции, в нашем случае синхронизируем метод 
экземпляра.

Чтобы предотвратить возникновение состояния гонки, нужно чтобы код критической секции выполнялся как атомарная
инструкция. Т.е. как только один поток выполняет его, никакие другие потоки не могут его выполнить,
пока первый поток не покинет критическую секцию.

Распространённые способы решения:

+ Использование локальной копии — копирование разделяемой переменной в локальную переменную потока.
  Этот способ работает, если переменная одна и копирование производится атомарно (за одну машинную команду).
+ Синхронизация - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании
  ключевого слова `synchronized`).
+ Комбинирование методов - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в
  синхронизированном блоке. С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться
  от слишком больших синхронизированных блоков.

Очевидных способов выявления и исправления состояний гонки не существует.
Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.

[к оглавлению](#multithreading)

## 20. Что такое Thread Local переменная? 

`ThreadLocal` - класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.

У каждого потока - т.е. экземпляра класса `Thread` - есть ассоциированная с ним таблица _ThreadLocal-переменных_. 
Ключами таблицы являются cсылки на объекты класса `ThreadLocal`, а значениями - ссылки на объекты, «захваченные» 
ThreadLocal-переменными, т.е. ThreadLocal-переменные отличаются от обычных переменных тем, что у каждого потока свой 
собственный, индивидуально инициализируемый экземпляр переменной. Доступ к значению можно получить через методы `get()`
или `set()`.

Например, если мы объявим ThreadLocal-переменную: `ThreadLocal<Object> locals = new ThreadLocal<Object>();`. А затем, в 
потоке, сделаем `locals.set(myObject)`, то ключом таблицы будет ссылка на объект `locals`, а значением - ссылка на 
объект `myObject`. При этом для другого потока существует возможность «положить» внутрь `locals` другое значение.

Следует обратить внимание, что `ThreadLocal` изолирует именно ссылки на объекты, а не сами объекты. Если изолированные 
внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.

Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках, то инициализация такой переменной должна 
происходить в том же потоке, в котором она будет использоваться. Ошибкой является инициализация такой переменной (вызов 
метода `set()`) в главном потоке приложения, потому как в данном случае значение, переданное в методе `set()`, будет 
«захвачено» для главного потока, и при вызове метода `get()` в целевом потоке будет возвращен `null`.

[к оглавлению](#multithreading)

## 21. Что такое FutureTask?

**`FutureTask`** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. Этот класс 
предоставляет базовую реализацию `Future`, с методами для запуска и остановки вычисления, методами для запроса состояния 
вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, метод получения 
будет заблокирован, если вычисление ещё не завершено. Объекты `FutureTask` могут быть использованы для обёртки объектов 
`Callable` и `Runnable`. Т.к. `FutureTask` реализует `Runnable`, его можно передать в `Executor` на выполнение.

[к оглавлению](#multithreading)

## 22. Что такое Thread Pool?

Создание потока является затратной по времени и ресурсам операцией. Количество потоков, которое может быть запущено в 
рамках одного процесса также ограниченно. Чтобы избежать этих проблем и в целом управлять множеством потоков более 
эффективно в Java был реализован механизм пула потоков (thread pool), который создаётся во время запуска приложения и в 
дальнейшем потоки для обработки запросов берутся и переиспользуются уже из него. Т.е. появляется возможность не терять 
потоки, сбалансировать приложение по количеству потоков и частоте их создания.

Начиная с Java 1.5 Java API предоставляет фреймворк `Executor`, который позволяет создавать различные типы пула потоков.

**Типы пула потоков:**

+ `Executor` - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;
+ `ExecutorService` - расширенный интерфейс пула, с возможностью завершения всех потоков;
+ `AbstractExecutorService` - базовый класс пула, реализующий интерфейс `ExecutorService`;
+ `Executors` - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;
+ `ThreadPoolExecutor` - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;
+ `ForkJoinPool` - пул для выполнения задач типа `ForkJoinTask`;
+ ... и другие.

**Методы `Executors` для создания пулов:**

+ `newCachedThreadPool()` - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул.
  Потоки не используемые больше минуты завершаются и удалются из кэша. Размер пула неограничен. Предназначен для 
  выполнения множество небольших асинхронных задач;
+ `newCachedThreadPool(ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой потоков;
+ `newFixedThreadPool(int nThreads)` - создает пул на указанное число потоков. Если новые задачи добавлены, когда все 
  потоки активны, то они будут сохранены в очереди для выполнения позже. Если один из потоков завершился из-за ошибки, 
  на его место будет запущен другой поток. Потоки живут до тех пор, пока пул не будет закрыт явно методом shutdown().
+ `newFixedThreadPool(int nThreads, ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой 
  потоков;
+ `newSingleThreadScheduledExecutor()` - однопотоковый пул с возможностью выполнять задачу через указанное время или 
  выполнять периодически. Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет 
  создан новый поток.
+ `newSingleThreadScheduledExecutor(ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой 
  потоков;
+ `newScheduledThreadPool(int corePoolSize)` - пул для выполнения задач через указанное время или переодически;
+ `newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной 
  фабрикой потоков;
+ `unconfigurableExecutorService(ExecutorService executor)` - обертка на пул, запрещающая изменять его конфигурацию;

[к оглавлению](#multithreading)

## 23. Что такое Semaphore?

`Semaphore` – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. Доступ 
управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, когда 
поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то 
увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого 
блока.

Семафоры в Java представлены классом `Semaphore`.

При создании объектов-семафоров мы можем использовать такие конструкторы:

```java
Semaphore(int permits)
Semaphore(int permits, boolean fair)
```

В конструктор мы передаем:
+ `int permits`  — начальное и максимальное значение счетчика. То есть то, сколько потоков одновременно могут иметь 
  доступ к общему ресурсу;
+ `boolean fair` — для установления порядка, в котором потоки будут получать доступ. Если fair = true, доступ 
  предоставляется ожидающим потокам в том порядке, в котором они его запрашивали. Если же он равен false, порядок будет 
  определять планировщик потоков.

`Semaphore` используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к
базе данных в пуле.


[к оглавлению](#multithreading)

## 24. Чем отличается submit от execute у ExecutorServices?

Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница:

+ `execute(Runnable command)` определён в интерфейсе `Executor` и выполняет поданную задачу и ничего не возвращает.

+ `submit()` – перегруженный метод, определённый в интерфейсе `ExecutorService`. Способен принимать задачи типов 
  `Runnable` и `Callable` и возвращать объект `Future`, который можно использовать для контроля и управления процессом 
  выполнения, получения его результата.

[к оглавлению](#multithreading)

## 25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?

+ `void shutdown()` просто скажет службе исполнителя, что она не может принимать новые задачи, но уже отправленные
  задачи продолжат выполняться.

+ `List<Runnable> shutdownNow()` сделает то же самое и попытается отменить уже отправленные задачи, прерывая 
  соответствующие потоки. Возвращает список ожидаемых задач выполнение.
  
Если ваши задачи игнорируют прерывание, то `shutdownNow()` будет вести себя точно так же, как и `shutdown()`.

[к оглавлению](#multithreading)

## 26. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.

Для одного:
```java
ExecutorService service = Executors.newSingleThreadExecutor();
```

Например, если надо создать пул с 5ю потоками, то делается это так:
```java
ExecutorService service = Executors.newFixedThreadPool(5);
```

Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости,
но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время),
то это задается следующим образом:
```java
ExecutorService service = Executors.newCachedThreadPool();
```

[к оглавлению](#multithreading)

## 27. Что такое ReadWriteLock?

**`ReadWriteLock`** – это интерфейс расширяющий базовый интерфейс `Lock`. Используется для улучшения производительности
в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи).
Такие локи необычайно полезны, когда в системе много операций чтения и мало операций записи. Несколько задач могут 
читать данные одновременно при условии, что ни одна задача не пытается их записывать. Если установлена блокировка 
записи, то чтение становится невозможным до её освобождения.

Интерфейс `ReadWriteLock` реализован классом `ReentrantReadWriteLock`,
который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.
```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock rLock = rwLock.readLock();
Lock wLock = rwLock.writeLock();

wLock.lock();
try {
    // exclusive write
} finally {
    wLock.unlock();
}
        
rLock.lock();
try {
    // shared reading
} finally {
    rLock.unlock();
}      
```

[к оглавлению](#multithreading)

## 28. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().

`FutureTask` базируется на конкретной реализации `Future` интерфейса и обеспечивает асинхронную обработку. Он содержит 
методы для запуска и отмены таска, а также методы получения состояния `FutureTask`.

У `Future` есть метод `Future.cancel(boolean)`, который должен отменить выполнение задачи.
В недрах реализации `FutureTask` выполняется код:

```java
if (mayInterruptIfRunning) {
    Thread r = runner;
    if (r != null) {
        r.interrupt(); 
    }
}
```

[к оглавлению](#multithreading)

## 29. Расскажите про шаблон проектирования Producer Consumer.

Шаблон заключается в разделении потоков по виду их деятельности на поставщиков и потребителей. Поставщики и потребители 
не общаются друг с другом напрямую, вместо этого передавая работу через общую очередь.

Такой подход позволяет независимо разрабатывать поставщиков и потребителей, так как они не знают друг о друге, но знают 
только формат общения.

Другое преимущество - возможность поставщиков и потребителей работать на разной скорости: медленный потребитель не будет 
тормозить быстрого поставщика.